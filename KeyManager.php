<?php
/**
 * KeyManager.php (Lite, API-only)
 *
 * - TANPA ekstensi OpenSSL
 * - TANPA phpseclib
 * - Generate RSA key pair via tool web 8gwifi (HTML parsing)
 * - Validasi dasar (PEM markers + sanity ASN.1 DER) di pure PHP
 *
 * PERINGATAN KEAMANAN:
 * - Private key dihasilkan oleh pihak ketiga (8gwifi). Untuk produksi, SANGAT disarankan
 *   generate lokal (OpenSSL/phpseclib). Kelas ini hanya untuk kebutuhan darurat/dev.
 * - Passphrase TIDAK dapat diterapkan tanpa OpenSSL/phpseclib → parameter $passphrase diabaikan.
 */

if (!defined('KEYS_DIR')) {
    define('KEYS_DIR', __DIR__ . '/keys');
}

class KeyManager
{
    // Opsi: path CA bundle untuk verifikasi TLS cURL (unduh dari https://curl.se/ca/cacert.pem)
    const CA_BUNDLE = __DIR__ . '/cacert.pem';

    /**
     * Generate RSA Key Pair via 8gwifi (API-tool HTML).
     * @param int    $keySize   2048 atau 4096
     * @param string $passphrase Diabaikan (tanpa OpenSSL/phpseclib tidak bisa enkripsi private key)
     * @param string $keyName   Nama file (opsional)
     * @return array            Hasil & metadata
     */
    public static function generateKeyPair($keySize = 2048, $passphrase = '', $keyName = '')
    {
        // Validasi size
        if (!in_array($keySize, [2048, 4096], true)) {
            return ['success' => false, 'error' => 'Invalid key size. Use 2048 or 4096'];
        }

        // Nama aman
        if (empty($keyName)) {
            $keyName = 'rsa_' . $keySize . '_' . date('YmdHis');
        }
        $keyName = preg_replace('/[^a-zA-Z0-9_\-]/', '', $keyName);

        // Pastikan direktori
        if (!is_dir(KEYS_DIR) && !mkdir(KEYS_DIR, 0700, true)) {
            return ['success' => false, 'error' => 'Cannot create keys directory: ' . KEYS_DIR];
        }

        try {
            $res = self::generateViaAPI($keySize, $keyName);
            if (!empty($res['success'])) {
                // Tandai bahwa passphrase diabaikan
                $res['has_passphrase'] = false;
                $res['passphrase_note'] = 'Passphrase ignored (no OpenSSL/phpseclib).';
                return $res;
            }
        } catch (Exception $e) {
            return ['success' => false, 'error' => 'API generation failed: ' . $e->getMessage()];
        }

        return ['success' => false, 'error' => 'Unknown error'];
    }

    /**
     * Pemanggilan 8gwifi (HTML) + parsing kunci.
     * @param int    $keySize
     * @param string $keyName
     * @return array
     * @throws Exception
     */
    private static function generateViaAPI($keySize, $keyName)
    {
        $apiUrl = "https://8gwifi.org/RSAFunctionality?keysize={$keySize}&keyformat=PKCS1";

        $response = self::httpGet($apiUrl);
        $keys = self::parseAPIResponse($response);

        if (empty($keys['private']) || empty($keys['public'])) {
            throw new Exception('Failed to extract keys from API response');
        }

        // Simpan file
        $privateKeyPath = KEYS_DIR . '/' . $keyName . '_private.pem';
        $publicKeyPath  = KEYS_DIR . '/' . $keyName . '_public.pem';

        if (file_put_contents($privateKeyPath, $keys['private']) === false) {
            throw new Exception('Cannot write private key to ' . $privateKeyPath);
        }
        if (file_put_contents($publicKeyPath, $keys['public']) === false) {
            @unlink($privateKeyPath);
            throw new Exception('Cannot write public key to ' . $publicKeyPath);
        }

        @chmod($privateKeyPath, 0600);
        @chmod($publicKeyPath, 0644);

        // Validasi dasar
        $valid = self::validateKeyPair($publicKeyPath, $privateKeyPath);

        return [
            'success'          => true,
            'key_name'         => $keyName,
            'key_size'         => $keySize,
            'size'             => $keySize,
            'private_key_path' => $privateKeyPath,
            'public_key_path'  => $publicKeyPath,
            'has_passphrase'   => false, // tidak didukung
            'created_at'       => date('Y-m-d H:i:s'),
            'method'           => 'API (8gwifi.org) - HTML parsed',
            'validated'        => $valid,
            'warning'          => 'Keys generated by third-party tool. Do NOT use for production.'
        ];
    }

    /**
     * HTTP GET dengan cURL (TLS verify jika CA bundle tersedia).
     * @param string $url
     * @return string
     * @throws Exception
     */
    private static function httpGet($url)
    {
        $ch = curl_init();
        $hasCA = file_exists(self::CA_BUNDLE);

        curl_setopt_array($ch, [
            CURLOPT_URL            => $url,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_CONNECTTIMEOUT => 10,
            CURLOPT_TIMEOUT        => 30,
            CURLOPT_SSL_VERIFYPEER => $hasCA,   // verify jika ada CA bundle
            CURLOPT_SSL_VERIFYHOST => $hasCA ? 2 : 0,
            CURLOPT_CAINFO         => $hasCA ? self::CA_BUNDLE : null,
            CURLOPT_USERAGENT      => 'KeyManagerLite/1.0 (+PHP cURL)'
        ]);

        $response = curl_exec($ch);
        $http     = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $errNo    = curl_errno($ch);
        $errStr   = curl_error($ch);
        curl_close($ch);

        // Retry sekali untuk timeout / 5xx tanpa response
        if (($errNo === CURLE_OPERATION_TIMEDOUT || $http >= 500) && empty($response)) {
            usleep(250000);
            return self::httpGet_noRetry($url);
        }

        if ($http !== 200 || empty($response)) {
            throw new Exception('HTTP GET failed: ' . ($errStr ?: 'HTTP ' . $http));
        }

        return $response;
    }

    /**
     * Helper GET tanpa retry (dipanggil oleh httpGet saat retry).
     */
    private static function httpGet_noRetry($url)
    {
        $ch = curl_init();
        $hasCA = file_exists(self::CA_BUNDLE);

        curl_setopt_array($ch, [
            CURLOPT_URL            => $url,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_CONNECTTIMEOUT => 10,
            CURLOPT_TIMEOUT        => 30,
            CURLOPT_SSL_VERIFYPEER => $hasCA,
            CURLOPT_SSL_VERIFYHOST => $hasCA ? 2 : 0,
            CURLOPT_CAINFO         => $hasCA ? self::CA_BUNDLE : null,
            CURLOPT_USERAGENT      => 'KeyManagerLite/1.0 (+PHP cURL)'
        ]);

        $response = curl_exec($ch);
        $http     = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $errStr   = curl_error($ch);
        curl_close($ch);

        if ($http !== 200 || empty($response)) {
            throw new Exception('HTTP GET retry failed: ' . ($errStr ?: 'HTTP ' . $http));
        }
        return $response;
    }

    /**
     * Ekstrak blok PEM dari HTML 8gwifi (lebih toleran).
     * @param string $html
     * @return array ['private'=>..., 'public'=>...]
     */
    private static function parseAPIResponse($html)
    {
        $html = str_replace(["\r\n", "\r"], "\n", $html);

        $private = '';
        $public  = '';

        // Private key: PKCS#1 atau PKCS#8
        $privPatterns = [
            '/-----BEGIN RSA PRIVATE KEY-----(.+?)-----END RSA PRIVATE KEY-----/s',
            '/-----BEGIN PRIVATE KEY-----(.+?)-----END PRIVATE KEY-----/s',
        ];
        foreach ($privPatterns as $pat) {
            if (preg_match($pat, $html, $m)) {
                $private = trim($m[0]) . "\n";
                break;
            }
        }

        // Public key: SubjectPublicKeyInfo atau RSA PUBLIC KEY
        $pubPatterns = [
            '/-----BEGIN PUBLIC KEY-----(.+?)-----END PUBLIC KEY-----/s',
            '/-----BEGIN RSA PUBLIC KEY-----(.+?)-----END RSA PUBLIC KEY-----/s',
        ];
        foreach ($pubPatterns as $pat) {
            if (preg_match($pat, $html, $m)) {
                $public = trim($m[0]) . "\n";
                break;
            }
        }

        return ['private' => $private, 'public' => $public];
    }

    /**
     * Daftar key pair yang tersimpan.
     * @return array
     */
    public static function listKeyPairs()
    {
        if (!is_dir(KEYS_DIR)) return [];

        $list = [];
        $files = glob(KEYS_DIR . '/*_private.pem');
        if (!$files) return [];

        foreach ($files as $priv) {
            $name = basename($priv, '_private.pem');
            $pub  = KEYS_DIR . '/' . $name . '_public.pem';
            if (!file_exists($pub)) continue;

            $size = self::approximateKeySizeFromPublic($pub);
            // Provide both 'key_size' (used by some endpoints) and 'size' (used by frontend JS)
            $list[] = [
                'name'        => $name,
                'key_size'    => $size ?: 'Unknown',
                'size'        => $size ?: 'Unknown',
                'private_key' => $priv,
                'public_key'  => $pub,
                'created'     => date('Y-m-d H:i:s', filemtime($priv)),
            ];
        }
        return $list;
    }

    /**
     * Hapus pasangan kunci berdasarkan nama.
     * @param string $keyName
     * @return bool
     */
    public static function deleteKeyPair($keyName)
    {
        $privateFile = KEYS_DIR . '/' . $keyName . '_private.pem';
        $publicFile  = KEYS_DIR . '/' . $keyName . '_public.pem';

        $deleted = false;
        if (file_exists($privateFile)) { @unlink($privateFile); $deleted = true; }
        if (file_exists($publicFile))  { @unlink($publicFile);  $deleted = true; }
        return $deleted;
    }

    /**
     * Validasi dasar pasangan kunci tanpa OpenSSL:
     * - Cek marker PEM
     * - Cek DER ASN.1 awalan (SEQUENCE 0x30) pada public key
     * @param string $publicKeyPath
     * @param string $privateKeyPath
     * @return bool
     */
    public static function validateKeyPair($publicKeyPath, $privateKeyPath)
    {
        if (!file_exists($publicKeyPath) || !file_exists($privateKeyPath)) return false;

        $pub = @file_get_contents($publicKeyPath);
        $pri = @file_get_contents($privateKeyPath);
        if ($pub === false || $pri === false) return false;

        $hasPub = (strpos($pub, '-----BEGIN PUBLIC KEY-----') !== false) ||
                  (strpos($pub, '-----BEGIN RSA PUBLIC KEY-----') !== false);
        $hasPri = (strpos($pri, '-----BEGIN RSA PRIVATE KEY-----') !== false) ||
                  (strpos($pri, '-----BEGIN PRIVATE KEY-----') !== false);

        if (!$hasPub || !$hasPri) return false;

        // Cek ASN.1 DER minimum di public key (harapannya SubjectPublicKeyInfo)
        $der = self::pem2der($pub);
        if ($der === null || strlen($der) < 8) return false;

        // DER harus mulai dengan SEQUENCE (0x30)
        $p = 0;
        if (ord($der[$p]) !== 0x30) return false;

        // Lewati panjang SEQUENCE
        $lenInfo = self::asn1ReadLength($der, $p + 1);
        if ($lenInfo === null) return false;
        // Tidak perlu validasi seluruh struktur, cukup cek tidak out-of-bounds
        [$len, $lenBytes] = $lenInfo;
        $totalLen = 1 + $lenBytes + $len;
        if ($totalLen > strlen($der)) return false;

        return true;
    }

    /**
     * Konversi PEM ke DER (return string biner atau null)
     */
    private static function pem2der($pem)
    {
        if (!preg_match('/-----BEGIN (?:RSA )?PUBLIC KEY-----([^-]+)-----END (?:RSA )?PUBLIC KEY-----/s', $pem, $m)) {
            return null;
        }
        $b64 = preg_replace('/\s+/', '', $m[1]);
        $bin = base64_decode($b64, true);
        return ($bin === false) ? null : $bin;
    }

    /**
     * Baca ASN.1 length pada posisi $pos (setelah tag).
     * Return [length, bytesConsumed] atau null.
     */
    private static function asn1ReadLength($der, $pos)
    {
        if ($pos >= strlen($der)) return null;
        $first = ord($der[$pos]);
        if ($first < 0x80) {
            return [$first, 1];
        }
        $numBytes = $first & 0x7F;
        if ($numBytes === 0 || $numBytes > 4) return null; // sederhana saja
        if ($pos + 1 + $numBytes > strlen($der)) return null;
        $len = 0;
        for ($i = 0; $i < $numBytes; $i++) {
            $len = ($len << 8) | ord($der[$pos + 1 + $i]);
        }
        return [$len, 1 + $numBytes];
        // Catatan: tidak menangani indefinite form (jarang untuk SPKI).
    }

    /**
     * Estimasi ukuran kunci dari public key PEM (tanpa lib):
     * - Ambil panjang base64 body → heuristik untuk 2048/4096
     * - Kembalikan 2048, 4096, atau null
     */
    private static function approximateKeySizeFromPublic($pubPath)
    {
        $pem = @file_get_contents($pubPath);
        if ($pem === false) return null;

        if (!preg_match('/-----BEGIN (?:RSA )?PUBLIC KEY-----([^-]+)-----END (?:RSA )?PUBLIC KEY-----/s', $pem, $m)) {
            return null;
        }
        $b64 = preg_replace('/\s+/', '', $m[1]);
        $len = strlen($b64);

        // Heuristik kasar (kisaran dapat berbeda antar encoding, jadi pakai rentang toleran)
        // Pengamatan umum (SPKI base64 body):
        // ~ 392–450 chars ~ 2048-bit
        // ~ 720–780 chars ~ 4096-bit
        if ($len >= 360 && $len <= 500)  return 2048;
        if ($len >= 680 && $len <= 900)  return 4096;

        return null;
    }

    /**
     * Ambil isi public key berdasarkan nama (string atau false)
     */
    public static function getPublicKey($keyName)
    {
        $file = KEYS_DIR . '/' . $keyName . '_public.pem';
        return file_exists($file) ? file_get_contents($file) : false;
    }

    /**
     * Ambil isi private key berdasarkan nama (string atau false)
     */
    public static function getPrivateKey($keyName)
    {
        $file = KEYS_DIR . '/' . $keyName . '_private.pem';
        return file_exists($file) ? file_get_contents($file) : false;
    }
}
